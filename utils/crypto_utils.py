# -*- coding: utf-8 -*-
"""crypto_utils.py - Crypto Payout Utilities (Production Ready)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1orW7Hq0f_ZN-0qS-uJBSk6CibRD1JLwA
"""

# crypto_utils.py
import os
import random
import time
from datetime import datetime
import logging

# --- IMPORTANT: Ensure these libraries are installed via requirements.txt ---
# pip install web3 tronpy
from web3 import Web3
from tronpy import Tron
from tronpy.keys import PrivateKey
from tronpy.exceptions import TronError

logging.basicConfig(level=logging.INFO) # Use INFO for production logging

# --- ERC20 ABI (simplified for transfer and decimals) ---
def erc20_abi():
    """Returns a simplified ABI for ERC20 transfer and decimals functions."""
    return [
        {"constant":False,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
        {"constant":True,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"type":"function"}
    ]

def send_erc20_payout(private_key, to_address, amount, contract_address, infura_url):
    """
    Sends ERC20 tokens (e.g., USDT) to a specified address on the Ethereum network.
    This function will attempt to connect to the provided Infura URL.
    """
    logging.info(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Initiating ERC20 payout to {to_address} for {amount} via contract {contract_address}")

    if not all([private_key, to_address, amount, contract_address, infura_url]):
        logging.error("Missing ERC20 payout parameters (private key, to_address, amount, contract_address, or infura_url).")
        raise ValueError("Missing ERC20 payout parameters.")

    try:
        # Initialize Web3 provider
        web3 = Web3(Web3.HTTPProvider(infura_url))
        if not web3.is_connected():
            logging.error(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Failed to connect to Ethereum node via Infura URL: {infura_url}")
            raise ConnectionError("Failed to connect to Ethereum node.")

        # Get account from private key
        acct = web3.eth.account.from_key(private_key)
        logging.info(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Connected to Ethereum. Sender address: {acct.address}")

        # Get contract instance
        contract = web3.eth.contract(address=web3.toChecksumAddress(contract_address), abi=erc20_abi())

        # Get token decimals
        decimals = contract.functions.decimals().call()
        amt_wei = int(float(amount) * (10 ** decimals))

        # Get nonce for the transaction
        nonce = web3.eth.get_transaction_count(acct.address)

        # Build the transaction
        tx = contract.functions.transfer(web3.toChecksumAddress(to_address), amt_wei).build_transaction({
            'chainId': web3.eth.chain_id, # Dynamically get chain ID from connected node
            'gas': 90000,  # Adjust gas limit as needed for ERC20 transfers
            'gasPrice': web3.eth.gas_price, # Use current gas price
            'nonce': nonce,
        })

        # Sign and send the transaction
        signed_tx = acct.sign_transaction(tx)
        tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)
        tx_hash_hex = web3.to_hex(tx_hash)

        logging.info(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: ERC20 Payout successful. Tx Hash: {tx_hash_hex}")
        return tx_hash_hex
    except ConnectionError as e:
        logging.critical(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Connection error during ERC20 payout: {e}", exc_info=True)
        raise # Re-raise for error handling in calling service
    except ValueError as e:
        logging.error(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Value error during ERC20 payout (e.g., invalid address, private key): {e}", exc_info=True)
        raise
    except Exception as e:
        logging.critical(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Unexpected error sending ERC20 payout: {e}", exc_info=True)
        raise # Re-raise for error handling in calling service

def send_trc20_payout(tron_private_key, to_address, amount, contract_address):
    """
    Sends TRC20 tokens to a specified address on the Tron network.
    """
    logging.info(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Initiating TRC20 payout to {to_address} for {amount} via contract {contract_address}")

    if not all([tron_private_key, to_address, amount, contract_address]):
        logging.error("Missing TRC20 payout parameters (private key, to_address, amount, or contract_address).")
        raise ValueError("Missing TRC20 payout parameters.")

    try:
        # Initialize Tron client. For production, explicitly configure full and solidity nodes.
        # Example for Nile Testnet: client = Tron(full_node="https://api.nileex.io", sol_node="https://api.nileex.io")
        # Example for Mainnet: client = Tron(full_node="https://api.trongrid.io", sol_node="https://api.trongrid.io")
        client = Tron() # Defaults to mainnet if no config provided

        # Get private key object
        priv_key = PrivateKey(bytes.fromhex(tron_private_key))
        logging.info(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Connected to Tron. Sender address: {priv_key.public_key.to_base58check_address()}")

        # Get contract instance
        contract = client.get_contract(contract_address)

        # Get token decimals
        decimals = contract.functions.decimals() # This typically returns an int directly in tronpy
        amt = int(float(amount) * (10 ** decimals))

        # Build the transaction
        txn = (
            contract.functions.transfer(to_address, amt)
            .with_owner(priv_key.public_key.to_base58check_address())
            .fee_limit(2_000_000)  # Adjust fee limit as needed (in SUN, 1 TRX = 1,000,000 SUN)
            .build()
            .sign(priv_key)
        )

        # Broadcast the transaction
        result = txn.broadcast()
        txid = result.get('txid')

        if not txid:
            # Check for specific Tron error messages
            error_message = result.get('message', 'No TXID returned')
            if 'error' in result and 'message' in result['error']:
                error_message = result['error']['message']
            logging.error(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: TRC20 broadcast failed: {error_message}")
            raise TronError(f"TRC20 broadcast failed: {error_message}")

        logging.info(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: TRC20 Payout successful. Tx Hash: {txid}")
        return txid
    except TronError as e:
        logging.error(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Tron-specific error during TRC20 payout: {e}", exc_info=True)
        raise
    except ValueError as e:
        logging.error(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Value error during TRC20 payout (e.g., invalid address, private key): {e}", exc_info=True)
        raise
    except Exception as e:
        logging.critical(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] crypto_utils.py: Unexpected error sending TRC20 payout: {e}", exc_info=True)
        raise # Re-raise for error handling in calling service
